# Detailed Implementation Plan for PubMed Scraper App

Based on the PRD, here's a comprehensive implementation plan following your preferred order: Frontend → API Preparation → Backend → Integration.

## Phase 1: Frontend Development (Next.js)

### 1.1 Project Structure Setup
- **Already Done**: Basic Next.js structure exists
- **Next Steps**: Organize components and services according to clean architecture principles

```
frontend/src/
├── app/
│   ├── api/                      # API layer
│   │   ├── jobsApi.ts
│   │   ├── articlesApi.ts
│   │   └── exportApi.ts
│   ├── jobs/
│   │   ├── new/page.tsx          # Job creation form
│   │   └── [id]/page.tsx         # Job details & results
│   ├── utils/                    # Utility functions
│   │   ├── validation.ts
│   │   └──formatting.ts
│   ├── types/                    # TypeScript definitions
│   │   ├── job.types.ts
│   │   ├── article.types.ts
│   │   └── api.types.ts
│   └── constants.ts
│   ├── globals.css
│   ├── layout.tsx
│   └── page.tsx                  # Dashboard/landing
├── components/
│   ├── ui/                       # Reusable UI components
│   │   ├── Button.tsx
│   │   ├── Input.tsx
│   │   ├── Table.tsx
│   │   ├── ProgressBar.tsx
│   │   ├── StatusChip.tsx
│   │   └── Modal.tsx
│   ├── job/                      # Job-specific components
│   │   ├── JobForm.tsx
│   │   ├── JobConfigSection.tsx
│   │   ├── ResultsTable.tsx
│   │   ├── ArticleRow.tsx
│   │   ├── RetryButton.tsx
│   │   └── ExportMenu.tsx
│   └── layout/                   # Layout components
│       ├── Header.tsx
│       ├── Navigation.tsx
│       └── Footer.tsx
└── hooks/                        # Custom React hooks
    ├── useJob.ts
    ├── useArticles.ts
    └── usePolling.ts




```

### 1.2 Core UI Components (Building Blocks)
Following your clean architecture rules, each component will be single-purpose and under 200 lines:

**Base UI Components** user ShadCN:
- `Button.tsx` - Reusable button with variants (primary, secondary, danger)
- `Input.tsx` - Form input with validation states
- `Table.tsx` - Data table with sorting, filtering, selection
- `ProgressBar.tsx` - Progress indicator with percentages
- `StatusChip.tsx` - Status badges (Queued, Running, Complete, Failed)
- `Modal.tsx` - Modal dialogs for confirmations

### 1.3 Job-Specific Components
**JobForm Component** (for `/jobs/new`):
- Query input with validation
- Advanced options (max results, date range, PMC only)
- Concurrency settings
- File naming patterns
- Real-time query validation

**ResultsTable Component** (for `/jobs/[id]`):
- Article list with status, title, PMID, source
- Filterable by status (Downloaded, Failed, Skipped)
- Selectable rows for bulk operations
- Per-row actions (retry, preview, download)

**JobProgress Component**:
- 4-stage progress indicator (Search → Resolve → Crawl → Download)
- Real-time status updates
- Error summaries

### 1.4 Page Implementation

**Landing Page** (`/page.tsx`):
- Dashboard showing recent jobs
- Quick start button
- Job statistics overview

**New Job Page** (`/jobs/new/page.tsx`):
- JobForm component
- Query validation
- Job creation flow

**Job Details Page** (`/jobs/[id]/page.tsx`):
- JobProgress component
- ResultsTable component
- Export functionality
- Real-time updates via polling

## Phase 2: API Service Layer (Frontend)

### 2.1 TypeScript Type Definitions
Create comprehensive types matching the backend schema:

```typescript
// job.types.ts
export interface Job {
  id: string;
  created_at: string;
  name: string;
  query: string;
  max_results: number;
  date_from?: string;
  date_to?: string;
  pmc_only: boolean;
  allow_external: boolean;
  concurrency: number;
  status: JobStatus;
  error_msg?: string;
}

export enum JobStatus {
  QUEUED = 'queued',
  SEARCHING = 'searching',
  RESOLVING = 'resolving',
  DOWNLOADING = 'downloading',
  COMPLETED = 'completed',
  FAILED = 'failed'
}

// article.types.ts
export interface Article {
  id: string;
  job_id: string;
  pmid: string;
  title: string;
  pubmed_url: string;
  pmc_id?: string;
  external_url?: string;
  chosen_pdf_url?: string;
  status: ArticleStatus;
  failure_reason?: string;
  retries: number;
}

export enum ArticleStatus {
  PENDING_URLS = 'pending_urls',
  RESOLVED = 'resolved',
  DOWNLOADING = 'downloading',
  DOWNLOADED = 'downloaded',
  FAILED_SEARCH = 'failed_search',
  FAILED_PAYWALL = 'failed_paywall',
  SKIPPED_NO_PMC = 'skipped_no_pmc',
  SKIPPED_ROBOTS = 'skipped_robots'
}
```

### 2.2 API Service Implementation
Create service classes for each domain:

**JobsApi Service**:
```typescript
class JobsApiService {
  async createJob(jobData: CreateJobRequest): Promise<Job>
  async getJob(jobId: string): Promise<Job>
  async searchJob(jobId: string): Promise<Job>
  async resolveJob(jobId: string): Promise<Job>
  async downloadJob(jobId: string): Promise<Job>
  async exportJob(jobId: string, format: 'csv' | 'json'): Promise<Blob>
  async exportJobZip(jobId: string): Promise<Blob>
}
```

**ArticlesApi Service**:
```typescript
class ArticlesApiService {
  async getJobArticles(jobId: string): Promise<Article[]>
  async retryArticle(articleId: string): Promise<Article>
  async crawlArticle(articleId: string): Promise<Article>
}
```

### 2.3 Mock Data & Stubbed Endpoints
Create mock implementations that return realistic data for UI development:

```typescript
// Mock data for development
export const mockJob: Job = {
  id: 'job_123',
  name: 'Atrial Fibrillation Research',
  query: '("atrial fibrillation"[tiab]) AND (malnutrition[tiab])',
  status: JobStatus.DOWNLOADING,
  // ... other fields
};

export const mockArticles: Article[] = [
  {
    id: 'art_1',
    pmid: '12345678',
    title: 'Effects of malnutrition on atrial fibrillation outcomes',
    status: ArticleStatus.DOWNLOADED,
    // ... other fields
  },
  // ... more mock articles
];
```

## Phase 3: Backend Development (FastAPI)

### 3.1 Database Schema & Models
Implement the SQLite schema as defined in the PRD:

```python
# models/database.py
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey, Text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship

Base = declarative_base()

class Job(Base):
    __tablename__ = "jobs"
    
    id = Column(String, primary_key=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    name = Column(String, nullable=False)
    query = Column(Text, nullable=False)
    max_results = Column(Integer, default=100)
    date_from = Column(String, nullable=True)
    date_to = Column(String, nullable=True)
    pmc_only = Column(Boolean, default=False)
    allow_external = Column(Boolean, default=True)
    concurrency = Column(Integer, default=3)
    status = Column(String, default="queued")
    error_msg = Column(Text, nullable=True)
    
    articles = relationship("Article", back_populates="job")

class Article(Base):
    __tablename__ = "articles"
    
    id = Column(String, primary_key=True)
    job_id = Column(String, ForeignKey("jobs.id"))
    pmid = Column(String, nullable=False)
    title = Column(Text, nullable=False)
    pubmed_url = Column(String, nullable=False)
    pmc_id = Column(String, nullable=True)
    external_url = Column(String, nullable=True)
    chosen_pdf_url = Column(String, nullable=True)
    status = Column(String, default="pending_urls")
    failure_reason = Column(Text, nullable=True)
    retries = Column(Integer, default=0)
    
    job = relationship("Job", back_populates="articles")
    downloads = relationship("Download", back_populates="article")

class Download(Base):
    __tablename__ = "downloads"
    
    id = Column(String, primary_key=True)
    article_id = Column(String, ForeignKey("articles.id"))
    file_path = Column(String, nullable=False)
    file_name = Column(String, nullable=False)
    mime = Column(String, nullable=False)
    size_bytes = Column(Integer, nullable=False)
    checksum = Column(String, nullable=False)
    downloaded_at = Column(DateTime, default=datetime.utcnow)
    
    article = relationship("Article", back_populates="downloads")
```

### 3.2 Business Logic Services
Create service classes for each major operation:

**JobService**:
- Job creation and validation
- Status management
- Progress tracking

**PubMedService**:
- Query validation
- API integration
- Result parsing

**CrawlerService**:
- URL resolution
- PDF detection
- Robots.txt compliance

**DownloadService**:
- PDF downloading
- File validation
- Duplicate detection

### 3.3 API Endpoints Implementation
Implement all endpoints defined in the PRD:

```python
# routes/jobs.py
@router.post("/jobs", response_model=JobResponse)
async def create_job(job_data: CreateJobRequest, db: Session = Depends(get_db)):
    # Implementation

@router.post("/jobs/{job_id}/search")
async def search_job(job_id: str, db: Session = Depends(get_db)):
    # Implementation

@router.post("/jobs/{job_id}/resolve")
async def resolve_job(job_id: str, db: Session = Depends(get_db)):
    # Implementation

@router.post("/jobs/{job_id}/download")
async def download_job(job_id: str, db: Session = Depends(get_db)):
    # Implementation

@router.get("/jobs/{job_id}/results")
async def get_job_results(job_id: str, db: Session = Depends(get_db)):
    # Implementation

@router.get("/jobs/{job_id}/export")
async def export_job(job_id: str, format: str = "csv", db: Session = Depends(get_db)):
    # Implementation
```

### 3.4 Background Task Processing
Implement async task processing for long-running operations:

```python
# tasks/background.py
from celery import Celery

app = Celery('pubmed_scraper')

@app.task
def search_pubmed_task(job_id: str):
    # Async PubMed search implementation

@app.task
def resolve_sources_task(job_id: str):
    # Async source resolution

@app.task
def download_pdfs_task(job_id: str):
    # Async PDF downloads
```

## Phase 4: Integration & Testing

### 4.1 Frontend-Backend Integration
- Replace mock API services with real HTTP calls
- Implement error handling and loading states
- Add real-time polling for job status updates
- Configure CORS for development

### 4.2 End-to-End Testing
- Test complete user flows from job creation to export
- Validate error handling and retry mechanisms
- Performance testing with larger datasets
- UI/UX testing for all user scenarios

### 4.3 Production Deployment
- Docker containerization
- Environment configuration
- Database migrations
- Static file serving

## Development Timeline Estimate

**Week 1-2**: Frontend Core (Components + Pages)
**Week 3**: API Service Layer + Mock Integration
**Week 4-5**: Backend Core (Models + Basic Endpoints)
**Week 6-7**: PubMed Integration + Crawling Logic
**Week 8**: Integration + Testing
**Week 9**: Polish + Deployment

This plan follows your architecture principles with clear separation of concerns, single-responsibility components, and modular design. Each phase builds upon the previous one, allowing for iterative development and testing.

Would you like me to start implementing any specific part of this plan?